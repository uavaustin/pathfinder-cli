use prost::Message;
use std::collections::LinkedList;
use std::io::Write;

/// A collection of protobuffers used
///
/// The .rs files can be found in 'target/build/pathfinder-cli-#/out/' where '#' refers to some
/// serialization number (ex. f9060ec09ab7d407).
pub mod protos {
    // Include protobuf files generated by prost_build from build location (ex. 'target/debug/build/pathfinder-cli-[serial #]/')
    include!(concat!(env!("OUT_DIR"), "/pathfinder.rs"));
}

/// Converts Flyzone protos into a vector of pathfinder flyzones
fn convert_proto_flyzones(flyzones: Vec<protos::Flyzone>) -> Vec<Vec<pathfinder::Location>> {
    flyzones
        .iter()
        .map(
            // Convert vector of Position protos into a vector of pathfinder::Locations
            |flyzone| {
                flyzone
                    .boundary
                    .iter()
                    .map(
                        // I assumed the flight field min altitude would be more important to keep than the max
                        |pos| {
                            pathfinder::Location::from_degrees(
                                pos.lat,
                                pos.lon,
                                flyzone.alt_msl_min as f32,
                            )
                        },
                    )
                    .collect()
            },
        )
        .collect()
}

/// Converts Obstacle protos into pathfinder::Obstacles if they have a position
fn convert_proto_obstacles(obstacles: Vec<protos::Obstacle>) -> Vec<pathfinder::Obstacle> {
    obstacles
        .iter()
        .filter(|o| o.pos.is_some())
        .map(|obs| {
            let pos = obs.pos.as_ref().unwrap();
            // return pathfinder::Obstacle to iterator
            pathfinder::Obstacle::from_degrees(
                pos.lon,
                pos.lat,
                obs.radius as f32,
                obs.height as f32,
            )
        })
        .collect()
}

/// Converts Waypoint protos into pathfinder::Waypoints if they have a position
fn convert_proto_raw_path(
    waypoints: Vec<protos::Waypoint>,
) -> LinkedList<pathfinder::Waypoint<()>> {
    waypoints
        .iter()
        .filter(|w| w.pos.is_some())
        .map(|waypoint| {
            let pos = waypoint.pos.as_ref().unwrap();
            // return pathfinder::Waypoint with radius of 1 meter to iterator
            pathfinder::Waypoint::from_degrees(pos.lon, pos.lat, waypoint.altitude as f32, 1.0)
        })
        .collect()
}

/// Converts Plane proto into pathfinder::Plane if it has a position, otherwise creates a default
/// from a pathfinder::Location
fn convert_proto_plane(
    plane: protos::Plane,
    default_location: pathfinder::Location,
) -> pathfinder::Plane {
    match plane.pos {
        Some(pos) => pathfinder::Plane::from_degrees(pos.lon, pos.lat, plane.altitude as f32),
        None => {
            // TODO: Decide if a default should be created or an error should occur
            pathfinder::Plane::from_degrees(
                default_location.lon(),
                default_location.lat(),
                plane.altitude as f32,
            )
        }
    }
}

/// Converts Iterator of pathfinder::Waypoints with no extra data to a proto Mission
fn convert_path_to_proto<T>(path: T) -> protos::Mission
where
    T: Iterator<Item = pathfinder::Waypoint<()>>,
{
    protos::Mission {
        // Get current time
        time: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .expect("Time is before Unix Epoch.")
            .as_millis() as f64,
        waypoints: path
            .map(|w| protos::Waypoint {
                pos: Some(protos::Position {
                    lat: w.location.lat(),
                    lon: w.location.lon(),
                }),
                altitude: w.location.alt() as f64,
            })
            .collect(),
    }
}

fn main() {
    // Load subcommands, options, etc. from YAML file
    let yaml = clap::load_yaml!("cli.yaml");
    // Get subcommands, options, etc. used in the command line
    let matches = clap::App::from_yaml(yaml).get_matches();
    // if matches.subcommand_name().is_none() {
    //     println!("Hello world!");
    // }

    // Read input
    // TODO: Properly handle all these .unwrap()s and Results
    let mut buffer = String::new();
    std::io::stdin().read_line(&mut buffer);

    // Convert hexadecimal string back into bytes and decode bytes into FlightField proto
    let ff_received_hex = hex::decode(&buffer).unwrap();
    let ff_received = protos::FlightField::decode(bytes::Bytes::from(ff_received_hex)).unwrap();

    buffer.clear();
    std::io::stdin().read_line(&mut buffer);

    // Convert hexadecimal string back into bytes and decode bytes into Plane proto
    let plane_received_hex = hex::decode(&buffer).unwrap();
    let plane_received = protos::Plane::decode(bytes::Bytes::from(plane_received_hex)).unwrap();

    buffer.clear();
    std::io::stdin().read_line(&mut buffer);

    // Convert hexadecimal string back into bytes and decode bytes into Mission proto
    let mission_received_hex = hex::decode(&buffer).unwrap();
    let mission_received =
        protos::Mission::decode(bytes::Bytes::from(mission_received_hex)).unwrap();

    // Convert Flyzone protos into a vector of pathfinder flyzones
    let flyzones = convert_proto_flyzones(ff_received.flyzones);

    // Convert Obstacle protos into pathfinder::Obstacles if they have a position
    let obstacles = convert_proto_obstacles(ff_received.obstacles);

    // Convert Waypoint protos into pathfinder::Waypoints if they have a position
    let raw_path = convert_proto_raw_path(mission_received.waypoints);
    // Ensure there is a raw path
    if raw_path.is_empty() {
        // TODO: Handle in a way that the service can understand
        eprintln!("The raw path must have at least one waypoint with a position.");
        return;
    }

    // Convert Plane proto into pathfinder::Plane if it has a position, otherwise create a default
    let plane = convert_proto_plane(plane_received, raw_path.front().unwrap().location);

    let mut pathfinder = pathfinder::Pathfinder::new(
        pathfinder::Tanstar::new(),
        pathfinder::TConfig::default(),
        flyzones,
        obstacles,
    );
    let adjusted_path = pathfinder.get_adjust_path(plane, raw_path);

    // Convert adjusted_path to a proto message
    let adjusted_path_proto = convert_path_to_proto(adjusted_path.into_iter());
    // Convert proto message into hexadecimal byte message
    let mut adjusted_path_bytes = vec![0_u8; 4096]; // TODO: Figure out a good buffer size
    adjusted_path_proto.encode(&mut adjusted_path_bytes);
    let adjusted_path_hex = hex::encode(adjusted_path_bytes);

    // Send adjusted path
    std::io::stdout().write(adjusted_path_hex.as_bytes());
}

#[cfg(test)]
mod tests {
    use super::*;
    use pathfinder::*;

    #[test]
    fn make_flyzone() {
        let _flyzone = vec![vec![
            Location::from_degrees(30.32469, -97.60466, 0f32),
            Location::from_degrees(30.32437, -97.60367, 0f32),
            Location::from_degrees(30.32356, -97.60333, 0f32),
        ]];
    }

    // TODO: Create test for 'convert_proto_flyzone'

    // TODO: Create test for 'convert_proto_obstacles'

    // TODO: Create test for 'convert_proto_raw_path'

    // TODO: Create test for 'convert_proto_plane'

    // TODO: Create test for 'convert_path_to_proto'

    #[test]
    fn create_and_read_message() {
        // TODO: Properly handle all these .unwrap()s and Results
        // Create and send Plane
        let plane = protos::Plane {
            time: 12.3,
            pos: Some(protos::Position {
                lat: 30.2849,
                lon: -97.7341,
            }),
            altitude: 123.4,
        };
        // Encode plane into a vector of bytes then into a hexadecimal string
        let mut plane_buf_8: Vec<u8> = Vec::with_capacity(256);
        plane.encode(&mut plane_buf_8);
        let plane_buf_hex = hex::encode(plane_buf_8);

        // Receive Plane
        // Convert hexadecimal string back into bytes and decode bytes back into proto
        let plane_received_hex = hex::decode(plane_buf_hex).unwrap();
        let plane_received = protos::Plane::decode(bytes::Bytes::from(plane_received_hex)).unwrap();

        assert_eq!(plane, plane_received);

        // Create and send FlightField
        let flight_field = protos::FlightField {
            time: 12.3,
            flyzones: vec![protos::Flyzone {
                alt_msl_max: 200.0,
                alt_msl_min: 10.0,
                boundary: vec![
                    protos::Position {
                        lat: 30.29,
                        lon: -97.73,
                    },
                    protos::Position {
                        lat: 30.2849,
                        lon: -97.8,
                    },
                    protos::Position {
                        lat: 30.28,
                        lon: -97.73,
                    },
                ],
            }],
            obstacles: vec![
                protos::Obstacle {
                    pos: Some(protos::Position {
                        lat: 30.285,
                        lon: -97.75,
                    }),
                    height: 20.0,
                    radius: 1.0,
                },
                protos::Obstacle {
                    pos: Some(protos::Position {
                        lat: 30.282,
                        lon: -97.77,
                    }),
                    height: 15.0,
                    radius: 2.1,
                },
            ],
        };
        // Encode flight_field into a vector of bytes then into a hexadecimal string
        let mut ff_buf_8: Vec<u8> = Vec::with_capacity(2048);
        flight_field.encode(&mut ff_buf_8);
        let ff_buf_hex = hex::encode(ff_buf_8);

        // Receive FlightField
        // Convert hexadecimal string back into bytes and decode bytes back into proto
        let ff_received_hex = hex::decode(ff_buf_hex).unwrap();
        let ff_received = protos::FlightField::decode(bytes::Bytes::from(ff_received_hex)).unwrap();

        assert_eq!(flight_field, ff_received);

        // Create and send Mission
        let mission = protos::Mission {
            time: 12.3,
            waypoints: vec![
                protos::Waypoint {
                    pos: Some(protos::Position {
                        lat: 30.2849,
                        lon: -97.7341,
                    }),
                    altitude: 123.4,
                },
                protos::Waypoint {
                    pos: Some(protos::Position {
                        lat: 30.285,
                        lon: -97.734,
                    }),
                    altitude: 75.0,
                },
            ],
        };
        // Encode plane into a vector of bytes then into a hexadecimal string
        let mut mission_buf_8: Vec<u8> = Vec::with_capacity(256);
        mission.encode(&mut mission_buf_8);
        let mission_buf_hex = hex::encode(mission_buf_8);

        // Receive Mission
        // Convert hexadecimal string back into bytes and decode bytes back into proto
        let mission_received_hex = hex::decode(mission_buf_hex).unwrap();
        let mission_received =
            protos::Mission::decode(bytes::Bytes::from(mission_received_hex)).unwrap();

        assert_eq!(mission, mission_received);
    }
}
