use prost::Message;
use std::io::{BufRead, Read, Write};

/// A collection of protobuffers used
pub mod protos {
    // Include protobuf files generated by prost_build from build location (ex. 'target/debug/build/pathfinder-cli-[serial #]/')
    include!(concat!(env!("OUT_DIR"), "/pathfinder.rs"));
}

// fn read(num_bytes: usize) -> std::io::Result<Vec<u8>> {
//     let mut pos_buf_read: Vec<u8> = Vec::with_capacity(num_bytes);
//     pos_buf_read.resize(pos_buf_read.capacity(), 0); // read_exact uses len() not capacity
//     match std::io::stdin().lock().read_exact(&mut pos_buf_read) {
//         Ok(_) => {
//             //println!("\npos_buf_read: {:?}", pos_buf_read);
//             Ok(pos_buf_read)
//         }
//         Err(e) => Err(e),
//     }
// }

fn main() {
    // Load subcommands, options, etc. from YAML file
    let yaml = clap::load_yaml!("cli.yaml");
    // Get subcommands, options, etc. used in the command line
    let matches = clap::App::from_yaml(yaml).get_matches();
    if matches.subcommand_name().is_none() {
        println!("Hello world!");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pathfinder::*;

    #[test]
    fn make_flyzone() {
        let _flyzone = vec![vec![
            Location::from_degrees(30.32469, -97.60466, 0f32),
            Location::from_degrees(30.32437, -97.60367, 0f32),
            Location::from_degrees(30.32356, -97.60333, 0f32),
        ]];
    }

    #[test]
    fn send_receive_message() {
        // Create and send Plane
        let plane = protos::Plane {
            time: 12.3,
            pos: Some(protos::Position {
                lat: 30.2849,
                lon: -97.7341,
            }),
            altitude: 123.4,
        };
        // Encode plane into a vector of bytes then into a hexadecimal string
        let mut plane_buf_8: Vec<u8> = Vec::with_capacity(256);
        plane.encode(&mut plane_buf_8).unwrap();
        let plane_buf_hex = hex::encode(plane_buf_8);

        // Receive Plane
        // Convert hexadecimal string back into bytes and decode bytes back into proto
        let plane_received_hex = hex::decode(plane_buf_hex).unwrap();
        let plane_received = protos::Plane::decode(bytes::Bytes::from(plane_received_hex)).unwrap();

        assert_eq!(plane, plane_received);

        // Create and send FlightField
        let flight_field = protos::FlightField {
            time: 12.3,
            flyzones: vec![protos::Flyzone {
                alt_msl_max: 200.0,
                alt_msl_min: 10.0,
                boundary: vec![
                    protos::Position {
                        lat: 30.29,
                        lon: -97.73,
                    },
                    protos::Position {
                        lat: 30.2849,
                        lon: -97.8,
                    },
                    protos::Position {
                        lat: 30.28,
                        lon: -97.73,
                    },
                ],
            }],
            obstacles: vec![
                protos::Obstacle {
                    pos: Some(protos::Position {
                        lat: 30.285,
                        lon: -97.75,
                    }),
                    height: 20.0,
                    radius: 1.0,
                },
                protos::Obstacle {
                    pos: Some(protos::Position {
                        lat: 30.282,
                        lon: -97.77,
                    }),
                    height: 15.0,
                    radius: 2.1,
                },
            ],
        };
        // Encode flight_field into a vector of bytes then into a hexadecimal string
        let mut ff_buf_8: Vec<u8> = Vec::with_capacity(2048);
        flight_field.encode(&mut ff_buf_8).unwrap();
        let ff_buf_hex = hex::encode(ff_buf_8);

        // Receive FlightField
        // Convert hexadecimal string back into bytes and decode bytes back into proto
        let ff_received_hex = hex::decode(ff_buf_hex).unwrap();
        let ff_received = protos::FlightField::decode(bytes::Bytes::from(ff_received_hex)).unwrap();

        assert_eq!(flight_field, ff_received);

        // Create and send Mission
        let mission = protos::Mission {
            time: 12.3,
            waypoints: vec![
                protos::Waypoint {
                    pos: Some(protos::Position {
                        lat: 30.2849,
                        lon: -97.7341,
                    }),
                    altitude: 123.4,
                },
                protos::Waypoint {
                    pos: Some(protos::Position {
                        lat: 30.285,
                        lon: -97.734,
                    }),
                    altitude: 75.0,
                },
            ],
        };
        // Encode plane into a vector of bytes then into a hexadecimal string
        let mut mission_buf_8: Vec<u8> = Vec::with_capacity(256);
        mission.encode(&mut mission_buf_8).unwrap();
        let mission_buf_hex = hex::encode(mission_buf_8);

        // Receive Mission
        // Convert hexadecimal string back into bytes and decode bytes back into proto
        let mission_received_hex = hex::decode(mission_buf_hex).unwrap();
        let mission_received =
            protos::Mission::decode(bytes::Bytes::from(mission_received_hex)).unwrap();

        assert_eq!(mission, mission_received);
        // Also you need to try to set up the cli to take in the mission (possibly separately, but
        // could also ask Chase about having a Mission proto that wraps up everything) inline (like
        // as an argument) as a string of hexadecimals, but that should possibly be changed to
        // be a live connection at some point.
    }
}
